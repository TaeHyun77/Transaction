DB는 트랜잭션 단위로 처리됨 ( All Or Nothing )

**[ 문제 상황 ]**

A → B → C 테이블에 순서로 데이터를 삽입하는 로직이 존재할 때

C 테이블에 삽입하기 전 서버 오류 발생 시 A, B 테이블에는 불완전한 데이터가 남음 

⇒ 데이터 정합성 문제 발생

**해결 방법, 트랜잭션 (All or Nothing 전략)**

- 트랜잭션을 적용하여 모든 작업(A, B, C 삽입)이 성공해야만 commit.
- 만약 중간에 오류가 발생하면 rollback하여 A, B에 삽입된 데이터도 취소 → 데이터의 정합성 유지

**트랜잭션 적용 시 동작 방식**

1. A, B, C 테이블에 데이터를 삽입하는 작업을 트랜잭션 단위로 묶음
2. C 테이블 삽입 전에 오류 발생 시 → A, B의 삽입된 데이터도 rollback.
3. 모든 테이블이 정상적으로 삽입되었을 때만 commit 수행

### **트랜잭션의 4가지 특성**

---

1. 원자성 ( Atomicity ) 
    
    트랜잭션은 더 이상 분해가 불가능한 작업의 최소 단위이며, 전부 처리 or 아무것도 처리 x
    
2. 일관성 ( Consistency )
    
    하나의 트랜잭션을 성공적으로 완료하고 나면 그 데이터베이스는 여전히 일관된 상태이어야 함
    
    ( 데이터베이스의 무결성 제약조건을 지켜야 함 )
    
    즉, 트랜잭션의 실행의 결과로 데이터베이스의 상태가 모순되지 않아야 함
    
3. 격리성 ( Isolation )
    
    트랜잭션들은 각각의 실행에 서로 영향을 끼치지 말아야함
    
4. 지속성 ( Durability )
    
    트랜잭션의 실행이 성공적으로 완료된다면 그 결과는 DB에 영구적으로 저장되어야 함
    
    ⇒ commit 되고 나면 데이터는 영구적으로 저장된다는 의미
    

### **트랜잭션의 격리성**

---

격리성이란 트랜잭션들은 각각의 실행에 서로 영향을 끼치지 말아야 한다는 ( 접근하지 말아야 한다 ) 정의를 가지고, 일반적으로 접근 레벨이 있으며 DB에 따라 설정이 가능

**격리성의 수준**

1. Read Uncommitted
    
    트랜잭션에서 처리 중인 아직 커밋되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용
    
    ( `Dirty Read`, `Non-Repeatable Read`, `Phantom Read`가 발생할 수 있음 )
    

1. Read Commited
    
    트랜잭션은 커밋되지 않은 변경 내용이 존재할 경우, Undo 로그를 이용해 가장 최근 커밋된 데이터를 읽음
    
    ⇒  MVCC ( Multi-Version Concurrency Control ) 기반의 동작
    
    > `MVCC : 하나의 데이터에 대해 여러 버전을 만들어 놓고, 트랜잭션마다 볼 수 있는 버전을 다르게 해서 충돌 없이 동작하도록 하는 방식`
    > 
    
    ( `Dirty Read`를 막지만,  `Non-Repeatable Read`와 `Phanton Read`가 발생할 수 있음 )
    

1. Repeatable Read
    
    `많은 DBMS( MySQL, PostgreSQL 등 )에서 Repeatable Read를 기본 격리 수준으로 설정하고 있음`
    
    한 트랜잭션 내에서 동일한 SELECT 쿼리를 반복 실행할 경우, 행에 대해서만 항상 같은 결과( 값 )를 보장
    
    ⇒ 어느 트랜잭션에서 처음 읽은 값은 트랜잭션이 끝날 때까지 처음 읽은 값으로 조회됨
    
    ```jsx
    트랜잭션 1과 트랜잭션 2가 있을 때
    트랜잭션 1에서 a값 500을 조회 ( undo에 값 저장 )
    트랜잭션 2에서 a의 값을 200으로 변경 ( 커밋 완료 상태 )
    트랜잭션 1에서 a의 값을 다시 조회 → 트랜잭션 1은 계속 500을 읽음
    
    즉, 트랜잭션 1은 트랜잭션 1이 종료될 때까지 500을 계속 읽음
    ⇒ 트랜잭션 내에서 맨 처음 읽었던 값을 계속 반환
    
    만약 트랜잭션 3이 a의 값을 읽는다면 이는 200을 읽음 
    ```
    
    ⇒ 트랜잭션 중 값의 변경에 대해 일정한 값으로 처리할 수 있음
    
    ⇒ ⭐️ `행에 대해서만` 반복해서 읽어도 항상 처음 읽은 동일한 값을 보장하지만, 조건에 부합하는 새로운 행이 추가되거나 삭제되면, 재조회 시 결과 집합( 행의 개수 )은 달라질 수 있음
    
    ( `Phanton Read`가 발생할 수 있음 )
    

1. Serializable Read
    
    트랜잭션 내에서 같은 쿼리를 여러 번 실행해도 데이터가 변경되거나 새로운 레코드가 추가되지 않도록 보장하는 가장 강력한 격리 수준
    
    한 트랜잭션이 끝날 때까지 다른 트랜잭션이 데이터를 추가, 수정, 삭제할 수 없도록 완벽히 차단
    
    병렬 처리 되므로 성능과 효율이 떨어져 잘 사용하지 않음
    
    ⇒ Repeatable에서 T가 읽는 중이여도 다른 T에서 추가, 수정, 삭제 가능 했는데 Serializable는 허용 안됨
    
    ( 모든 트랜잭션 문제가 차단 )
    

### **격리성으로 인한 문제점**

---

1. Dirty Read
    
    `다른 트랜잭션이 아직 커밋하지 않은 데이터를 읽는 것`
    
    ![image.png](attachment:a9b261e0-c583-45f7-947c-525d8cf985f7:image.png)
    

1. Non-Repeatable Read
    
    `하나의 row에서 SELECT를 두 번 했을 때, 값이 달라지는 현상`
    
    ![image.png](attachment:887797fa-87f9-403e-bb4d-3dd0af5d8d1a:image.png)
    

1. Phantom Read 
    
    `하나의 테이블에서 같은 조건으로 여러 번 조회했을 때, 처음엔 없던 새로운 행이 생겨서 결과가 달라지는 현상`
    
    ![image.png](attachment:663fb67f-b439-471b-8e98-1e4f82f33c5e:image.png)
    

**[ Phantom Read와 Non-Repeatuable Read의 차이 ]**

`Non-Repeatable Read` : 하나의 Row를 여러 번 조회했을 때 결과가 다른 것

`Phanton Read` : 여러 번 조회했을 때 처음엔 없던 행 자체가 새로 생기거나 사라지는 것
